chap08 쿠버네티스 실습환경 구축

--------------------------------------------------------------------------------------


도메인 네임
    : 도메인 네임에 대한 IP를 찾기 위해선 호스트는 "해당 호스트의 /etc/hosts 파일" -> "해당 호스트의 로컬 DNS 캐시" -> "해당 호스트가 속한 로컬 네트워크의 로컬 DNS " ->  "퍼블릭 DNS " 순으로 참조하게 된다.
    : DNS 
	1. Domain Name System 로써의 DNS >>  도메인 이름과 IP 주소를 매핑하는 시스템
	2.  Domain Name Server 로써의 DNS  >>   Domain Name System 이 돌아가는 실제 "서버"
		: 종류 
			(1) 로컬 DNS : 로컬 네트워크 내에서만 사용 가능한 Domain Name "Server"로, 도메인 네임을 private IP 혹은 public IP 에 바인딩한 정보를 저장한다.
			(2) 퍼블릭 DNS : 전세계 범위에서 사용되는 Domain Name "Server"로, 도메인 네임을  public IP에 바인딩한 정보를 저장한다

    : /etc/hosts >> IP 와 도메인 네임을 바인딩해놓은 "host내"의 "정적" "파일"
	: 사용자가 직접 정의/수정 가능
	: 도메인 네임에 대한 IP를 찾기 위해 host 는 가장 먼저 이 파일을 참조한다

    : 로컬 DNS 캐시 >> 해당 host 가 DNS 에 질의한 내역을 저장해놓은 "host 내"의 "동적인" "메모리/저장소"



UFW Uncomplicated FireWall >> 리눅스 운영체제에서 작동하는 방화벽
네트워크 드라이버  >>특정 네트워크 구조를 구현/관리하는 데 사용되는 도구
	ex ) docker 의 bridge , host, overlay 네트워크 드라이버
	ex ) kubernetes 의 overlay 네트워크 드라이버



전반적으로 자주 쓰이는 명령어
	: 명령어 권한 획득 >> sudo -i



Linux 설정 관련
    주요 디렉터리
	: 해당 디렉터리 아래 정의된 *.conf 파일은 해당 디렉터리의 기능(?)에 대한 설정 파일로 간주된다
	: 표준 디렉터리와 사용자 정의 디렉터리
		: 표준 디렉터리 >> 시스템 설치 시나 특정 패키지를 설치할 때 자동으로 생성됨
		: 사용자 정의 디렉터리 >> 
	1. /etc/modules-load.d 디렉터리 >>  Linux 시스템에서 "커널 모듈"을 자동으로 로드하기 위한 설정 디렉터리
		: Linux 커널 모듈 >> 시스템의 하드웨어나 소프트웨어 기능을 확장하기 위해 동적으로 로드될 수 있는 작은 코드 조각

	2. /etc/sysctl.d 디렉터리 >> 이 디렉터리 내의 설정 파일들은 시스템이 부팅될 때 자동으로 적용되며, 각각의 파일에는 여러 "커널 파라미터(=변수)들"이 정의됨.
		: 이 파일에 정의된 커널파라미터는 입력하자마자 바로 적용되는건 아니고, 시스템이 부팅될 떄마다 자동으로 적용되는데, 명령어(sysctl -p  /etc/sysctl.d/k8s.conf 혹은 sysctl --system)를 통해 바로 적용할 수도 있다.

			: 설정파일의 커널 파라미터에 할당되는 값 1 과 0 
				1 >> 각각의 기능을 활성화한다.
				0 >> 각각의 기능을 비활성화한다.

				
    통상적인 설정 파일명
	: 일단 .conf 확장자는 유지해야된다
 	:  k8s.conf 파일 >> 쿠버네티스 관련 설정파일은 통상적으로 k8s.conf 로 정의한다
		: 근데 꼭 k8s.conf 일 필욘 없다			

    명령어 
    	sysctl -p 와 sysctl --system
		: 설정 파일을 수정한다고 바로 반영되는건 아니고, 재부팅을 하거나 특정 명령어를 입력해야 바로 적용시킬 수 있다.
		: sysctl -p [특정파일]  >> 특정 파일의 커널 파라미터만 시스템에 즉시 적용
			: 디폴트론 /etc/sysctl.conf 파일이 적용됨
			: sysctl -p /etc/sysctl.d/k8s.conf 처럼 뒤에 특정 파일을 명시하면 해당 파일에 정의된 설정을 시스템에 즉시 적용 가능

		: sysctl --system  >> 시스템 내의 모든 설정 파일을 시스템에 즉시 적용


도커, 쿠버네티스에서의 오버레이 네트워크(= 서로 다른 host 의 pod 들을 동일한 네트워크에 존재하는 것처럼 만듦) 
	: 도커 환경에선 오버레이 네트워크의 구축을 위해 보통 overlay 네트워크 드라이버를, 쿠버네티스 환경에서는 오버레이 네트워크의 구축을 위해 CNI 플러그인을 주로 사용한다.




Cloud Native Computing Foundation CNCF >> 클라우드 네이티브 기술의 발전과 표준화를 촉진하기 위해 설립된 오픈소스 소프트웨어 재단
	: 클라우드 네이티브 기술 >>클라우드 환경에서 최적화된 애플리케이션을 설계/개발/배포/운영하는 기술
	: 클라우드 네이티브 애플리케이션을 구축하고 운영하기 위한 주요 기술/프로젝트들을 관리하고 지원
 		: Kubernetes, Prometheus, containerd, Helm 등을 관리



컨테이너 런타임 >> 컨테이너를 실행/관리하는 소프트웨어
	: 컨테이너의 생성, 실행, 중지, 삭제 등의 작업을 수행
	: 종류
		1. Low-level . 하위 런타임<< 기본적인. 저수준.
			: runc >> 가장 기본적인 컨테이너 런타임으로, OCI(Open Container Initiative) 표준을 구현
				:  Docker와 containerd 등의 High-level 컨테이너 런타임에서 활용됨
			
		2. High-level. 상위 런타임 <<  하위 컨테이너 런타임과 다른 상위 컨테이너 런타임을 활용하여 구현된 소프트웨어. (복잡한. 고수준) 
		 	: containerd >> Docker에서 파생된, 그렇지만 Docker와는 독립적인, 고성능 컨테이너 런타임으로, 컨테이너의 수명 주기를 관리하는 모든 기능을 제공. 
				: "Docker에서 파생" >> ( Docker 와 별개로 이전부터 존재했던게 아니라 ) Docker 에서  (핵심 컨테이너 관리 기능을 분리를) 필요로 해서 개발된 것이란 것.
				: "Docker와는 독립적" >> Docker 뿐 아니라 Kubernetes와 같은 다른 시스템에서도 사용 가능
					: containerd가 탄생한 건 Docker 때문이긴 해도, ( 2017년 ) Docker는 containerd를 오픈소스로 독립시키고, Cloud Native Computing Foundation(CNCF)에 기부했다

			: CRI-O >> Kubernetes에서 OCI 표준을 준수하는 컨테이너 런타임
				: Kubernetes와의 통합을 위해 설계됨

			: Docker >> containerd와 runc를 활용하여 컨테이너 관리 기능을 제공. 따라서 얘도 상위 컨테이너 런타임. 
		


8.1 쿠버네티스 설치전 사전준비
	: 쿠버네티스는 실습환경을 사전 구축한 후에 설치해야한다. 안그럼 설치에 실패할 수도..
	: (쿠버네티스 클러스터를 구성하기 위한) 사전준비 목록
		1.  다수의 가상 머신 생성
			: docker 실습할 때는 가상머신(myserver02) 하나만 사용했는데, (쿠버네티스는 서버가 여러대의 효율적인 사용을 위한 것이므로) 쿠버네티스 실습에서는 여러개의 가상머신을 준비해서 서버가 여러개 있는 것 같은 효과를 낸다
			: 구축 내역 >>  서버 3대로 쿠버네티스 클러스터 구축
				(1) 마스터 노드  <-- 1대
					1. myserver02

				(2) 워커노드 <-- 2대
					1. myserver03
					2. myserver04
				
			: 실습 절차
				(1) 가상머신 복제 >> docker 실습에 사용한 가상머신 myserver02를 복재
					1. myserver02 가상머신 탭 우클릭 , 복제 선택
					2. 아래와 같이 설정 후 '다음' 클릭
						(1) 가상머신의 이름 : 각각 myserver03, myserver04 
						(2) MAC 주소 정책( MAC Address Policy ) >> "모든 네트워크 어댑터의 새 MAC 주소 생성"을 선택

					3. 복제 방식을 '완전한 복제'를 선택 후 'finish' 클릭
						: 복제된 서버에 접속해보면 hostname 도 myserver02, IP주소도 myserver02의 IP로 진짜 myserver02가 완전 존똑으로 복사된 것을 확인 가능. 복제된 서버를 myserver03, myserver04로써 사용가능하게 하기 위해 다음 추가 설정 과정이 필요


		2.  각 가상머신의 설정
			: 단순 복제된 myserver03, myserver04를 실제로 myserver03, myserver04로써 작동하게 설정
			: 실습 절차
				: 각 가상머신 별 IP 설정이 안된 상태라 puTTY 로 접속해서 설정은 불가하고, virtualBox 에서 직접 입력해야됨

				(1) 각 가상머신(myserver02, myserver03, myserver04)의 전원 다 킴

				(2) host name (호스트 이름) 변경 
					: 설정전엔 죄다 hostname 이 myserver02인 상태

					1.  현재 가상머신의 호스트네임을 새로 설정 >> sudo hostnamectl set-hostname <새로운hostname>
					    : hostnamectl >> 시스템의 호스트네임을 설정하고 관리하는 명령어
					    : 그러니까 
						: myserver03에 접속해서 >> sudo hostnamectl set-hostname myserver03
						: myserver04에 접속해서 >> sudo hostnamectl set-hostname myserver04

					2. 호스트네임이 제대로 설정됬나 확인 >> cat /etc/hostname 
					    : /etc/hostname 파일>> 시스템의 호스트네임을 저장하고 있는 파일
					    : 그러니까 
						: myserver03에선>>  myserver03 나옴
						: myserver04에선>>  myserver04 나옴


					3. 시스템을 즉시 재부팅 >> sudo reboot now 
						: 새로운 호스트네임을 시스템에 적용하기 위해선 시스템을 재부팅해야됨

				(2) IP 주소 변경 
					: 설정 전엔 죄다 IP주소(enp0s3의 inet값)가 10.0.2.4(myserver02의 IP주소)인 상태
					: 쿠버네티스 클러스터를 구성하기 위해서는 세 가상머신 모드 IP 주소가 달라야되므로, 서로 다른 IP주소를 가지도록 설정

					1. /etc/netplan 에 00-installer-config.yaml 파일 작성
						: 교재대로하면 에러나고 이거 참고해서 해야됨>> https://betwe.tistory.com/entry/Ubuntu-netplan-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-IP-%EB%B3%80%EA%B2%BD

						: myserver03에선>> 

network:
  ethernets:
    enp0s3:
      addresses:
        - 10.0.2.5/24
      routes:
        - to: default
          via: 10.0.2.1
      nameservers:
        addresses:
          - 8.8.8.8
  version: 2

						: myserver04에선>>

network:
  ethernets:
    enp0s3:
      addresses:
        - 10.0.2.5/24
      routes:
        - to: default
          via: 10.0.2.1
      nameservers:
        addresses:
          - 8.8.8.8
  version: 2

					2. ifconfig해서 제대로 반영됬나 확인해보기 >> 각각 enp0s3 가 10.0.2.5/24, 10.0.2.6/24 으로 잘 나옴


				(3) /etc/hosts 파일 커스텀
					: 가상 머신간 도메인 네임을 통한 통신을 가능하게 하기 위해, 각 호스트의 /etc/hosts 로 각 가상머신의 private IP를 특정도메인네임과 바인딩해놓는다

					: 참고로 수정 전 hosts 파일(=myserver02의 hosts 파일)은 아래와 같음 

							127.0.0.1 localhost
							127.0.1.1 myserver02

							# The following lines are desirable for IPv6 capable hosts
							::1     ip6-localhost ip6-loopback
							fe00::0 ip6-localnet
							ff00::0 ip6-mcastprefix
							ff02::1 ip6-allnodes
							ff02::2 ip6-allrouters


					1. myserver02의 설정 수정
						: myserver02 에서도 도메인 네임을 통해 myserver03, myserver04 와의 통신을 할 수 있도록 수정한다

							127.0.0.1 localhost
							127.0.1.1 myserver02

							10.0.2.4 myserver02
							10.0.2.5 myserver03
							10.0.2.6 myserver04

							# The following lines are desirable for IPv6 capable hosts
							::1     ip6-localhost ip6-loopback
							fe00::0 ip6-localnet
							ff00::0 ip6-mcastprefix
							ff02::1 ip6-allnodes
							ff02::2 ip6-allrouters



					2. myserver03의 설정 수정
						(1) /etc/hosts 수정 
							127.0.0.1 localhost
							127.0.1.1 myserver03

							10.0.2.4 myserver02
							10.0.2.5 myserver03
							10.0.2.6 myserver04

							# The following lines are desirable for IPv6 capable hosts
							::1     ip6-localhost ip6-loopback
							fe00::0 ip6-localnet
							ff00::0 ip6-mcastprefix
							ff02::1 ip6-allnodes
							ff02::2 ip6-allrouters


 						(2) 제대로 반영됬나 확인
						     1. ping 날려보기 
							    : destination host unreachable 안나오고 64 bytes from .. icmp_seq =.. 같은거 찍히면 정상적인 거임
							(1) ping myserver02
							(2) ping myserver04

						     2. ssh 접속해보기
							(1) ssh myserver02
								: https://blog.acronym.co.kr/480

							(2) ssh myserver04



					3. myserver04의 설정 수정
						(1) /etc/hosts 수정 
							127.0.0.1 localhost
							127.0.1.1 myserver04

							10.0.2.4 myserver02
							10.0.2.5 myserver03
							10.0.2.6 myserver04

							# The following lines are desirable for IPv6 capable hosts
							::1     ip6-localhost ip6-loopback
							fe00::0 ip6-localnet
							ff00::0 ip6-mcastprefix
							ff02::1 ip6-allnodes
							ff02::2 ip6-allrouters


 						(2) 제대로 반영됬나 확인
						     1. ping 날려보기 
							(1) ping myserver02
							(2) ping myserver03

						     2. ssh 접속해보기
							(1) ssh myserver02
							(2) ssh myserver03



				(4) UFW 방화벽 설정
					: 쿠버네티스의 각 노드별로 포트 통신을 원활하게 하기 위해 기존에 사용하던 ufw를 정지시켜야됨.
					: myserver02, myserver03, myserver04 의 방화벽 정지 하는 법
						(1)  방화벽 상태 확인 >> sudo ufs status 
							: 결과로 "Status: inactive" 출력되면, 방화벽이 작동안하고 있는거라 별도의 정지 처리 과정을 안해줘도 됨. ( "Status: inactive" 출력되면 별도의 정지 처리 과정 필요 ) 
								: 실습에서는 다 "Status: inactive" 상태라 별도의 정
	
						(2)  ( "Status: inactive" 출력된 경우) ufw 정지시키기 >> sudo ufw disable



				(5) 네트워크 설정
					: myserver02, 03, 04 모두 똑같이 작업해준다.
					1. IPv4 를 포워딩
					    : IPv4 를 포워딩하여 iptables 가 연결된 트래픽을 볼 수 있게 함
						(1) 루트 권한 획득 >> sudo -i 
						(2) 파일 작성 >> 
							1. cat << EOF | sudo tee /etc/modules-load.d/k8s.conf 
								:  /etc/modules-load.d 디렉터리 >>  Linux 시스템에서 "커널 모듈"을 자동으로 로드하기 위한 설정 파일.
									: Linux 커널 모듈 >> 시스템의 하드웨어나 소프트웨어 기능을 확장하기 위해 동적으로 로드될 수 있는 작은 코드 조각
									: k8s.conf 파일 >> Kubernetes에서 요구하는 특정 커널 모듈들을 자동으로 로드하기 위해 사용됨

							    : 여러줄로 입력받은 내용을  /etc/modules-load.d/k8s.conf 
에 저장시키도록 하겠다
								: cat <<EOF 명령어 >> EOF(End of File) 문자열 전까지 입력된 내용을 표준 출력(stdout)으로 보냄.
								: tee 명령어  >>표준 입력(stdin)으로 전달된 내용을 특정 파일( tee바로 뒤 명시된 파일)에 쓰는 명령어. 

								: | (파이프) >> 앞에서 출력된 내용을 뒤의 명령어로 전달

							2. overlay 모듈 >> overlay	
								: 주의 ) 교재에서는 이 overlay를 네트워크 컨텍스트에서의 "overlay 네트워크 드라이버"라고 소개했는데, 이는 교재의 오류 같고 실제로는 "파일 시스템에서의 overlayFS" 를 의미하는 것 같다.
									: 참고) overlay 네트워크 드라이버란? >>  리눅스 커널의 네트워크 드라이버 
										: 서로 다른 host 에 존재하는 pod 간의 네트워크 연결을 가능하게 함
											: 즉, overlay network 의 구성을 가능하게 해준다
												: 그러니까 서로 다른 호스트의 pod 들을 동일한 네트워크에 있는 것처럼 할 수 있다


								: overlay 모듈 >> OverlayFS를 지원/활성화하는 Linux 커널 모듈. ( OverlayFS를 사용 가능하게하는 커널 모듈 )
									: OverlayFS 오버레이 파일 시스템 >> 여러 파일 시스템을 겹쳐서(=오버레이) 사용할 수 있게 해주는, Linux 커널에서 제공하는 파일 시스템 기능
										:  Docker 이미지의 레이어링 시스템에서  OverlayFS가 사용된다.
											: Docker 이미지의 각 레이어는 읽기 전용으로 제공되며, 컨테이너에서 발생하는 변경 사항은 읽기-쓰기 가능한 새로운 레이어에 기록된다.

										: 주요 개념
										    : 파일 시스템 레이어링 >> Lower Layer와 Upper Layer를 결합시킨 (하나의 통합된) 파일 시스템을 사용자에게 제공하는 것
											: Lower Layer, Upper Layer 	
												: Lower Layer >> 읽기 전용(=수정불가) 파일 시스템 레이어
												: Upper Layer >> 읽기-쓰기 가능한(=수정 가능) 파일 시스템 레이어
													: 새로운 파일이나 변경된 파일이 이 레이어에 저장됨

											: Merged View	
												: OverlayFS는 두 레이어(Lower Layer와 Upper Layer)를 결합하여 사용자에게 하나의 통합된 파일 시스템으로 보여준다.
													: 그러니까 사용자가 파일을 수정하거나 새로 생성할 때, 이 변경 사항은 Upper Layer에 기록되지만, Lower Layer와 결합된 하나의 파일 시스템으로 보인다.





									: 이 모듈을 로드(sudo modprobe overlay)함으로써  OverlayFS 기능을 활성화 가능
										: 그러니까 파일 시스템 레이어링과 같은 기능을 사용할 수 있음



							3. br_netfilter 모듈 >> br_netfilter 
								:  br_netfilter  >> 네트워크 필터링(패킷 처리) 관련 모듈
									: iptables/netfilter 규칙의 적용을 가능하게함
										: 그러니까 컨테이너와 호스트 간의 인터페이스 등에서 발생하는 트래픽에 대한 규칙을 적용 가능하게 함


							4. cat 명령어를 종료 >> EOF
								:  EOF 입력과 함께 cat 명령어가 종료되고, 앞서 입력한 내용이 /etc/modules-load.d/k8s.conf 파일에 기록됨

							
						(2) Linux 커널 모듈을 수동으로 로드 
						  	  : modprobe >> 리눅스 커널 모듈 관리 도구 
								: 특정 모듈을 로드/제거 가능

							1. overlay 모듈을 커널에 로드 >>  sudo modprobe overlay
								:  overlay 모듈을 커널에 로드하면, OverlayFS를 사용할 수 있는 상태가 된다.
							2. br_netfilter 모듈을 커널에 로드 >> sudo modprobe br_netfilter 


						(3) 또다른 파일 작성 <<  Kubernetes 환경에서 브리지 네트워크 트래픽과 패킷 포워딩을 제어하기 위해 필요한 커널 파라미터를 설정하는 과정임.
							1. cat << EOF | sudo tee /etc/sysctl.d/k8s.conf 
								: EOF 전까지 입력된 내용을 /etc/sysctl.d/k8s.conf 에 기록
							2.  브리지 네트워크 인터페이스에서 패킷이 iptables와 ip6tables 규칙을 통해 필터링되도록 설정
								(1) net.bridge.bridge-nf-call-iptables = 1
									: 브리지 네트워크 인터페이스에서 iptables를 통해 패킷 필터링을 가능하게 함.

								(2) net.bridge.bridge-nf-call-ip6tables = 1
									: 브리지 네트워크 인터페이스에서 IPv6 패킷이 ip6tables 규칙에 따라 필터링되도록 함.

							3. IPv4 패킷 포워딩을 활성화 >> net.ipv4.ip_forward = 1
								: 패킷 포워딩 >> 클러스터 내에서 패킷이 여러 네트워크 인터페이스를 통해 전달될 수 있도록 함.

							4. EOF



						(4)설정 파일 내용 반영


					2. containerd 를 설정
						: containerd >> 컨테이너 런타임.  컨테이너의 실행, 이미지 관리, 네트워크, 스냅샷 관리 등을 효율적으로 처리함.

						(1) sudo mkdir -p /etc/containerd : containerd의 설정 파일을 보관하기 위한 디렉터리 생성
							: -p 옵션 >>  이 옵션은 지정한 경로에 상위 디렉토리가 존재하지 않을 경우 상위 디렉터리도 함께 생성
							: /etc/constainerd >> containerd 관련 설정 파일이 디폴트로 저장되는 디렉터리
								: containerd 관련 설정 파일을 꼭 이 디렉터리에 저장해야하는건 아닌데, 다른 디렉터리에 저장하고 싶으면 별도의 설정을 해줘야된다

						(2) containerd config default | sudo tee /etc/containerd/config.toml > /dev/null  : containerd의 기본 설정을 /etc/containerd/config.toml 파일로 저장하되, 저장된 내용을 굳이 터미널에 출력하진 않는다(/dev/null).
							: containerd config default >> containerd의 기본 설정을 출력
							: config.toml >> containerd 의 구성요소( 네트워크, 스냅샷, 플러그인, 로그 설정 등)에 대한 설정 파일
								:  TOML Tom's Obvious, Minimal Language 형식>>  간단하고 사람이 읽기 쉬운 구성 파일 형식
								: 기본적으로 /etc/containerd/config.toml에 위치

							: /dev/null >> containerd 의 설정 파일
								: /dev/null >> Linux에서 사용하는 특수 파일로, 어떤 데이터도 저장하지 않는다.
									: 출력이나 로그를 무시 || 버리는데 사용된다
									: 터미널에 아무것도 표시하지 않게 한다


						(3) containerd config default | sudo tee /etc/containerd/config.toml > /dev/null  : config.toml 파일을 일부 수정
						    : 수정전 config.toml  파일은 다음과 같다
# Copyright 2018-2022 Docker Inc.

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#     http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

disabled_plugins = ["cri"]

#root = "/var/lib/containerd"
#state = "/run/containerd"
#subreaper = true
#oom_score = 0

[grpc]
  address = "/run/containerd/containerd.sock"
# uid = 0
# gid = 0

[debug]
  address = "/run/containerd/debug.sock"
# uid = 0
# gid = 0
# level = "info"


						    2. 교재에서의 containerd 와의 버전이 달라서 그런건진 몰라도 아예 SystemCGroup 에 대한 정의가 안되있어서 아예 직접 추가해줬다
[plugins."io.containerd.grpc.v1.cri".containerd.runtimes.runc]
  SystemdCgroup = true



		3. 네트워크 설정 및 swap 설정
