chap08 쿠버네티스 실습환경 구축

--------------------------------------------------------------------------------------


도메인 네임
    : 도메인 네임에 대한 IP를 찾기 위해선 호스트는 "해당 호스트의 /etc/hosts 파일" -> "해당 호스트의 로컬 DNS 캐시" -> "해당 호스트가 속한 로컬 네트워크의 로컬 DNS " ->  "퍼블릭 DNS " 순으로 참조하게 된다.
    : DNS 
	1. Domain Name System 로써의 DNS >>  도메인 이름과 IP 주소를 매핑하는 시스템
	2.  Domain Name Server 로써의 DNS  >>   Domain Name System 이 돌아가는 실제 "서버"
		: 종류 
			(1) 로컬 DNS : 로컬 네트워크 내에서만 사용 가능한 Domain Name "Server"로, 도메인 네임을 private IP 혹은 public IP 에 바인딩한 정보를 저장한다.
			(2) 퍼블릭 DNS : 전세계 범위에서 사용되는 Domain Name "Server"로, 도메인 네임을  public IP에 바인딩한 정보를 저장한다

    : /etc/hosts >> IP 와 도메인 네임을 바인딩해놓은 "host내"의 "정적" "파일"
	: 사용자가 직접 정의/수정 가능
	: 도메인 네임에 대한 IP를 찾기 위해 host 는 가장 먼저 이 파일을 참조한다

    : 로컬 DNS 캐시 >> 해당 host 가 DNS 에 질의한 내역을 저장해놓은 "host 내"의 "동적인" "메모리/저장소"



UFW Uncomplicated FireWall >> 리눅스 운영체제에서 작동하는 방화벽
네트워크 드라이버  >>특정 네트워크 구조를 구현/관리하는 데 사용되는 도구
	ex ) docker 의 bridge , host, overlay 네트워크 드라이버
	ex ) kubernetes 의 overlay 네트워크 드라이버



전반적으로 자주 쓰이는 명령어
	: 명령어 권한 획득 >> sudo -i



쿠버네티스에서의 오버레이 네트워크(= 서로 다른 host 의 pod 들을 동일한 네트워크에 존재하는 것처럼 만듦) 
    : 구축 방법
	:  overlay 네트워크 드라이버와  CNI 플러그인은 서로 독립적인 존재이다. (CNI 플러그인이 Overlay 네트워크를 구현할 때 반드시 Overlay 네트워크 드라이버를 내부적으로 사용하거나, Overlay 네트워크 드라이버가 CNI 플러그인을 사용해야 하는 것이 님)
	: 도커 환경에선 오버레이 네트워크의 구축을 위해 보통 overlay 네트워크 드라이버를, 쿠버네티스 환경에서는 오버레이 네트워크의 구축을 위해 CNI 플러그인을 주로 사용한다.
	sol1. overlay 네트워크 드라이버
******sol2. CNI 플러그인

8.1 쿠버네티스 설치전 사전준비
	: 쿠버네티스는 실습환경을 사전 구축한 후에 설치해야한다. 안그럼 설치에 실패할 수도..
	: (쿠버네티스 클러스터를 구성하기 위한) 사전준비 목록
		1.  다수의 가상 머신 생성
			: docker 실습할 때는 가상머신(myserver02) 하나만 사용했는데, (쿠버네티스는 서버가 여러대의 효율적인 사용을 위한 것이므로) 쿠버네티스 실습에서는 여러개의 가상머신을 준비해서 서버가 여러개 있는 것 같은 효과를 낸다
			: 구축 내역 >>  서버 3대로 쿠버네티스 클러스터 구축
				(1) 마스터 노드  <-- 1대
					1. myserver02

				(2) 워커노드 <-- 2대
					1. myserver03
					2. myserver04
				
			: 실습 절차
				(1) 가상머신 복제 >> docker 실습에 사용한 가상머신 myserver02를 복재
					1. myserver02 가상머신 탭 우클릭 , 복제 선택
					2. 아래와 같이 설정 후 '다음' 클릭
						(1) 가상머신의 이름 : 각각 myserver03, myserver04 
						(2) MAC 주소 정책( MAC Address Policy ) >> "모든 네트워크 어댑터의 새 MAC 주소 생성"을 선택

					3. 복제 방식을 '완전한 복제'를 선택 후 'finish' 클릭
						: 복제된 서버에 접속해보면 hostname 도 myserver02, IP주소도 myserver02의 IP로 진짜 myserver02가 완전 존똑으로 복사된 것을 확인 가능. 복제된 서버를 myserver03, myserver04로써 사용가능하게 하기 위해 다음 추가 설정 과정이 필요


		2.  각 가상머신의 설정
			: 단순 복제된 myserver03, myserver04를 실제로 myserver03, myserver04로써 작동하게 설정
			: 실습 절차
				: 각 가상머신 별 IP 설정이 안된 상태라 puTTY 로 접속해서 설정은 불가하고, virtualBox 에서 직접 입력해야됨

				(1) 각 가상머신(myserver02, myserver03, myserver04)의 전원 다 킴

				(2) host name (호스트 이름) 변경 
					: 설정전엔 죄다 hostname 이 myserver02인 상태

					1.  현재 가상머신의 호스트네임을 새로 설정 >> sudo hostnamectl set-hostname <새로운hostname>
					    : hostnamectl >> 시스템의 호스트네임을 설정하고 관리하는 명령어
					    : 그러니까 
						: myserver03에 접속해서 >> sudo hostnamectl set-hostname myserver03
						: myserver04에 접속해서 >> sudo hostnamectl set-hostname myserver04

					2. 호스트네임이 제대로 설정됬나 확인 >> cat /etc/hostname 
					    : /etc/hostname 파일>> 시스템의 호스트네임을 저장하고 있는 파일
					    : 그러니까 
						: myserver03에선>>  myserver03 나옴
						: myserver04에선>>  myserver04 나옴


					3. 시스템을 즉시 재부팅 >> sudo reboot now 
						: 새로운 호스트네임을 시스템에 적용하기 위해선 시스템을 재부팅해야됨

				(2) IP 주소 변경 
					: 설정 전엔 죄다 IP주소(enp0s3의 inet값)가 10.0.2.4(myserver02의 IP주소)인 상태
					: 쿠버네티스 클러스터를 구성하기 위해서는 세 가상머신 모드 IP 주소가 달라야되므로, 서로 다른 IP주소를 가지도록 설정

					1. /etc/netplan 에 00-installer-config.yaml 파일 작성
						: 교재대로하면 에러나고 이거 참고해서 해야됨>> https://betwe.tistory.com/entry/Ubuntu-netplan-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-IP-%EB%B3%80%EA%B2%BD

						: myserver03에선>> 

network:
  ethernets:
    enp0s3:
      addresses:
        - 10.0.2.5/24
      routes:
        - to: default
          via: 10.0.2.1
      nameservers:
        addresses:
          - 8.8.8.8
  version: 2

						: myserver04에선>>

network:
  ethernets:
    enp0s3:
      addresses:
        - 10.0.2.5/24
      routes:
        - to: default
          via: 10.0.2.1
      nameservers:
        addresses:
          - 8.8.8.8
  version: 2

					2. ifconfig해서 제대로 반영됬나 확인해보기 >> 각각 enp0s3 가 10.0.2.5/24, 10.0.2.6/24 으로 잘 나옴


				(3) /etc/hosts 파일 커스텀
					: 가상 머신간 도메인 네임을 통한 통신을 가능하게 하기 위해, 각 호스트의 /etc/hosts 로 각 가상머신의 private IP를 특정도메인네임과 바인딩해놓는다

					: 참고로 수정 전 hosts 파일(=myserver02의 hosts 파일)은 아래와 같음 

							127.0.0.1 localhost
							127.0.1.1 myserver02

							# The following lines are desirable for IPv6 capable hosts
							::1     ip6-localhost ip6-loopback
							fe00::0 ip6-localnet
							ff00::0 ip6-mcastprefix
							ff02::1 ip6-allnodes
							ff02::2 ip6-allrouters


					1. myserver02의 설정 수정
						: myserver02 에서도 도메인 네임을 통해 myserver03, myserver04 와의 통신을 할 수 있도록 수정한다

							127.0.0.1 localhost
							127.0.1.1 myserver02

							10.0.2.4 myserver02
							10.0.2.5 myserver03
							10.0.2.6 myserver04

							# The following lines are desirable for IPv6 capable hosts
							::1     ip6-localhost ip6-loopback
							fe00::0 ip6-localnet
							ff00::0 ip6-mcastprefix
							ff02::1 ip6-allnodes
							ff02::2 ip6-allrouters



					2. myserver03의 설정 수정
						(1) /etc/hosts 수정 
							127.0.0.1 localhost
							127.0.1.1 myserver03

							10.0.2.4 myserver02
							10.0.2.5 myserver03
							10.0.2.6 myserver04

							# The following lines are desirable for IPv6 capable hosts
							::1     ip6-localhost ip6-loopback
							fe00::0 ip6-localnet
							ff00::0 ip6-mcastprefix
							ff02::1 ip6-allnodes
							ff02::2 ip6-allrouters


 						(2) 제대로 반영됬나 확인
						     1. ping 날려보기 
							    : destination host unreachable 안나오고 64 bytes from .. icmp_seq =.. 같은거 찍히면 정상적인 거임
							(1) ping myserver02
							(2) ping myserver04

						     2. ssh 접속해보기
							(1) ssh myserver02
								: https://blog.acronym.co.kr/480

							(2) ssh myserver04



					3. myserver04의 설정 수정
						(1) /etc/hosts 수정 
							127.0.0.1 localhost
							127.0.1.1 myserver04

							10.0.2.4 myserver02
							10.0.2.5 myserver03
							10.0.2.6 myserver04

							# The following lines are desirable for IPv6 capable hosts
							::1     ip6-localhost ip6-loopback
							fe00::0 ip6-localnet
							ff00::0 ip6-mcastprefix
							ff02::1 ip6-allnodes
							ff02::2 ip6-allrouters


 						(2) 제대로 반영됬나 확인
						     1. ping 날려보기 
							(1) ping myserver02
							(2) ping myserver03

						     2. ssh 접속해보기
							(1) ssh myserver02
							(2) ssh myserver03



				(4) UFW 방화벽 설정
					: 쿠버네티스의 각 노드별로 포트 통신을 원활하게 하기 위해 기존에 사용하던 ufw를 정지시켜야됨.
					: myserver02, myserver03, myserver04 의 방화벽 정지 하는 법
						(1)  방화벽 상태 확인 >> sudo ufs status 
							: 결과로 "Status: inactive" 출력되면, 방화벽이 작동안하고 있는거라 별도의 정지 처리 과정을 안해줘도 됨. ( "Status: inactive" 출력되면 별도의 정지 처리 과정 필요 ) 
								: 실습에서는 다 "Status: inactive" 상태라 별도의 정
	
						(2)  ( "Status: inactive" 출력된 경우) ufw 정지시키기 >> sudo ufw disable



				(5) 네트워크 설정
					1. IPv4 를 포워딩
					    : IPv4 를 포워딩하여 iptables 가 연결된 트래픽을 볼 수 있게 함
						(1) 루트 권한 획득 >> sudo -i 
						(2) 파일 작성 >> 
							1. cat << EOF | sudo tee /etc/modules-load.d/k8s.conf 
							    : 여러줄로 입력받은 내용을  /etc/modules-load.d/k8s.conf 
에 저장시키도록 하겠다
								: cat <<EOF 명령어 >> EOF(End of File) 문자열 전까지 입력된 내용을 표준 출력(stdout)으로 보냄.
								: tee 명령어  >>표준 입력(stdin)으로 전달된 내용을 특정 파일( tee바로 뒤 명시된 파일)에 쓰는 명령어. 

								: | (파이프) >> 앞에서 출력된 내용을 뒤의 명령어로 전달

							2. overlay 네트워크 드라이버 >> overlay	
								: 주의 ) overlay 라는 용어는 여러 컨텍스트(분야)에서 사용되고, 교재 실습에서의 overlay 는 네트워크 컨텍스트에서의 overlay (네트워크 드라이버)이다.


								: overlay >>  리눅스 커널의 네트워크 드라이버 
									: 서로 다른 host 에 존재하는 pod 간의 네트워크 연결을 가능하게 함
										: 즉, overlay network 의 구성을 가능하게 해준다
											: 그러니까 서로 다른 호스트의 pod 들을 동일한 네트워크에 있는 것처럼 할 수 있다

									: 주의 >> CNI 플러그인과 overlay 네트워크 드라이버는 서로 별개이다.
										: 둘다 overlay 네트워크를 구축하는데 쓰일 수 있는데, 서로를 필요로 하진 않는다.(CNI 플러그인이 Overlay 네트워크를 구현할 때 반드시 Overlay 네트워크 드라이버를 내부적으로 사용하거나, Overlay 네트워크 드라이버가 CNI 플러그인을 사용해야 하는 것은 아님)


							3. br_netfilter 모듈 >> br_netfilter 
								:  br_netfilter  >> 네트워크 필터링(패킷 처리) 관련 모듈
									: iptables/netfilter 규칙의 적용을 가능하게함
										: 그러니까 컨테이너와 호스트 간의 인터페이스 등에서 발생하는 트래픽에 대한 규칙을 적용 가능하게 함


							4. cat 명령어를 종료 >> EOF
								:  EOF 입력과 함께 cat 명령어가 종료되고, 앞서 입력한 내용이 /etc/modules-load.d/k8s.conf 파일에 기록됨

							
						(2) Linux 커널 모듈을 수동으로 로드 
						  	  : modprobe >> 리눅스 커널 모듈 관리 도구 
								: 특정 모듈을 로드/제거 가능

							1. overlay 모듈을 커널에 로드 >>  sudo modprobe overlay
							2. br_netfilter 모듈을 커널에 로드 >> sudo modprobe br_netfilter 


						(3) 또다른 파일 작성 
							1. cat << EOF | sudo tee /etc/sysctl.d/k8s.conf 





		3. 네트워크 설정 및 swap 설정

